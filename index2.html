<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Campus Map Explorer - Cyber Modern</title>
    <script src="https://unpkg.com/lucide@latest"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <style>
        :root {
            /* Modern Dark Palette */
            --bg-color: #020617; /* Slate 950 */
            --surface: rgba(15, 23, 42, 0.75); /* Slate 900 Glass */
            --surface-hover: rgba(30, 41, 59, 0.8);
            
            --primary: #6366f1; /* Indigo 500 */
            --primary-glow: rgba(99, 102, 241, 0.5);
            
            --accent: #f43f5e; /* Rose 500 */
            --accent-glow: rgba(244, 63, 94, 0.5);
            
            --text-main: #f8fafc; /* Slate 50 */
            --text-muted: #94a3b8; /* Slate 400 */
            
            --border: rgba(255, 255, 255, 0.1);
            --glass-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.4);
            
            /* Status Colors */
            --color-default: #e2e8f0;
            --color-visiting: #fbbf24; /* Amber 400 */
            --color-visited: #34d399; /* Emerald 400 */
        }

        * { box-sizing: border-box; outline: none; -webkit-tap-highlight-color: transparent; }

        body {
            font-family: 'Inter', sans-serif;
            margin: 0;
            padding: 0;
            background-color: var(--bg-color);
            color: var(--text-main);
            height: 100vh;
            width: 100vw;
            overflow: hidden;
            display: flex;
        }

        /* Canvas */
        #canvas-wrapper {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            background: radial-gradient(circle at center, #0f172a 0%, #020617 100%);
            z-index: 1;
            cursor: default;
        }
        
        #canvas-wrapper.pan-mode { cursor: grab; }
        #canvas-wrapper.pan-mode:active { cursor: grabbing; }
        #canvas-wrapper.delete-mode { cursor: not-allowed; }

        /* Glass Panel */
        .glass-panel {
            position: absolute;
            top: 24px; left: 24px;
            width: 320px;
            background: var(--surface);
            backdrop-filter: blur(16px);
            -webkit-backdrop-filter: blur(16px);
            border: 1px solid var(--border);
            border-radius: 20px;
            padding: 24px;
            box-shadow: var(--glass-shadow);
            z-index: 10;
            display: flex;
            flex-direction: column;
            gap: 20px;
            max-height: calc(100vh - 48px);
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
        }

        /* Collapsed Panel */
        .glass-panel.collapsed {
            width: 60px;
            height: 60px;
            padding: 0;
            border-radius: 50%;
            cursor: pointer;
            overflow: hidden;
            background: var(--surface);
            border-color: rgba(255,255,255,0.2);
        }

        .glass-panel.collapsed .content-area { display: none; }
        
        .header-area {
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .glass-panel.collapsed .header-area {
            width: 100%; height: 100%;
            justify-content: center;
        }
        
        .glass-panel.collapsed h1 { display: none; }

        .collapse-btn {
            background: transparent;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            padding: 8px;
            border-radius: 50%;
            transition: 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        
        .collapse-btn:hover { color: var(--text-main); background: rgba(255,255,255,0.1); }

        h1 {
            font-size: 1.1rem;
            font-weight: 700;
            margin: 0;
            letter-spacing: -0.02em;
            background: linear-gradient(to right, #818cf8, #c084fc);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        h2 {
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.1em;
            color: var(--text-muted);
            margin: 0 0 10px 0;
            font-weight: 600;
        }

        /* Buttons */
        .btn-grid {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 8px;
        }
        
        .btn-grid.wide { grid-template-columns: 1fr 1fr; }

        button.tool-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            gap: 6px;
            padding: 12px 0;
            background: rgba(255,255,255,0.03);
            border: 1px solid transparent;
            border-radius: 12px;
            color: var(--text-muted);
            cursor: pointer;
            transition: all 0.2s ease;
            font-size: 0.75rem;
            font-weight: 500;
        }

        button.tool-btn:hover {
            background: rgba(255,255,255,0.08);
            color: var(--text-main);
            transform: translateY(-2px);
        }

        button.tool-btn.active {
            background: rgba(99, 102, 241, 0.15);
            color: #a5b4fc;
            border-color: rgba(99, 102, 241, 0.4);
            box-shadow: 0 0 15px rgba(99, 102, 241, 0.1);
        }

        button.tool-btn.danger.active {
            background: rgba(244, 63, 94, 0.15);
            color: #fda4af;
            border-color: rgba(244, 63, 94, 0.4);
        }

        button.action-btn {
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            padding: 12px;
            border-radius: 12px;
            border: none;
            font-weight: 600;
            font-size: 0.9rem;
            cursor: pointer;
            transition: all 0.2s;
            color: white;
            position: relative;
            overflow: hidden;
        }

        button.action-btn.primary {
            background: linear-gradient(135deg, var(--primary), #4f46e5);
            box-shadow: 0 4px 12px rgba(79, 70, 229, 0.3);
        }
        
        button.action-btn.secondary {
            background: linear-gradient(135deg, #ec4899, #db2777);
            box-shadow: 0 4px 12px rgba(236, 72, 153, 0.3);
        }

        button.action-btn:hover {
            filter: brightness(1.1);
            transform: translateY(-1px);
        }

        button.text-btn {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text-muted);
            padding: 8px;
            width: 100%;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.8rem;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 6px;
        }
        button.text-btn:hover { background: rgba(255,255,255,0.05); color: var(--text-main); }
        button.text-btn.danger:hover { color: #f87171; border-color: rgba(248, 113, 113, 0.3); }

        /* Inputs */
        select {
            width: 100%;
            padding: 12px;
            background: rgba(0,0,0,0.2);
            border: 1px solid var(--border);
            border-radius: 10px;
            color: var(--text-main);
            font-family: inherit;
            cursor: pointer;
            outline: none;
        }
        select:focus { border-color: var(--primary); }

        /* Log */
        .log-box {
            background: rgba(0,0,0,0.3);
            border-radius: 10px;
            padding: 12px;
            height: 100px;
            overflow-y: auto;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            color: #34d399;
            border: 1px solid var(--border);
        }
        .log-entry { margin-bottom: 4px; opacity: 0.8; }
        .log-entry::before { content: "> "; color: var(--text-muted); }

        /* Zoom Controls */
        .zoom-controls {
            position: absolute;
            bottom: 30px; right: 30px;
            display: flex;
            flex-direction: column;
            gap: 10px;
            z-index: 20;
        }

        .circle-btn {
            width: 44px; height: 44px;
            border-radius: 50%;
            background: var(--surface);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            color: var(--text-main);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: 0.2s;
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        .circle-btn:hover { background: var(--surface-hover); transform: scale(1.1); }

        /* Legend */
        .legend-pill {
            position: absolute;
            bottom: 30px; left: 50%;
            transform: translateX(-50%);
            background: var(--surface);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border);
            padding: 8px 24px;
            border-radius: 100px;
            display: flex;
            gap: 20px;
            z-index: 10;
            pointer-events: none;
        }
        .legend-item { display: flex; align-items: center; gap: 8px; font-size: 0.8rem; font-weight: 500; }
        .dot { width: 8px; height: 8px; border-radius: 50%; box-shadow: 0 0 8px currentColor; }

        /* Instructions */
        .instructions-toast {
            position: absolute;
            top: 30px; left: 50%;
            transform: translateX(-50%);
            background: var(--primary);
            color: white;
            padding: 8px 20px;
            border-radius: 100px;
            font-size: 0.9rem;
            font-weight: 600;
            box-shadow: 0 10px 25px -5px rgba(99, 102, 241, 0.4);
            z-index: 5;
            pointer-events: none;
            transition: all 0.3s;
            opacity: 1;
        }

        /* Modal */
        .modal-backdrop {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(5px);
            z-index: 100;
            display: none;
            justify-content: center;
            align-items: center;
            opacity: 0;
            transition: opacity 0.3s;
        }
        .modal-active { opacity: 1; }
        
        .modal-content {
            background: #1e293b;
            border: 1px solid var(--border);
            padding: 30px;
            border-radius: 20px;
            width: 320px;
            box-shadow: 0 25px 50px -12px rgba(0,0,0,0.5);
            transform: scale(0.9);
            transition: transform 0.3s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .modal-active .modal-content { transform: scale(1); }

        .modal-content h3 { margin: 0 0 20px 0; color: white; }
        .modal-content input {
            width: 100%; padding: 12px;
            background: #0f172a; border: 1px solid var(--border);
            color: white; border-radius: 8px; margin-bottom: 20px;
        }
        .modal-content input:focus { border-color: var(--primary); }

        /* Utility */
        .separator { height: 1px; background: var(--border); margin: 10px 0; }
        
        #toast {
            position: fixed; bottom: 100px; left: 50%;
            transform: translateX(-50%);
            background: #ef4444; color: white;
            padding: 10px 24px; border-radius: 50px;
            font-weight: 600; display: none; z-index: 100;
            box-shadow: 0 10px 15px -3px rgba(239, 68, 68, 0.3);
        }

    </style>
</head>
<body>

    <!-- Main Canvas -->
    <div id="canvas-wrapper">
        <canvas id="graphCanvas"></canvas>
    </div>

    <!-- Instructions Overlay -->
    <div id="instructions" class="instructions-toast">
        Click anywhere to add a Node
    </div>

    <!-- Control Panel -->
    <div class="glass-panel" id="mainPanel">
        <div class="header-area">
            <h1>
                <i data-lucide="network"></i>
                Map Explorer
            </h1>
            <button class="collapse-btn" onclick="toggleMenu()">
                <i data-lucide="chevrons-left" id="toggleIcon"></i>
            </button>
        </div>
        
        <div class="content-area">
            <div class="control-group">
                <h2>Toolkit</h2>
                <div class="btn-grid">
                    <button class="tool-btn active" onclick="setMode('node')" id="btn-node">
                        <i data-lucide="map-pin"></i> Node
                    </button>
                    <button class="tool-btn" onclick="setMode('edge')" id="btn-edge">
                        <i data-lucide="share-2"></i> Path
                    </button>
                    <button class="tool-btn" onclick="setMode('pan')" id="btn-pan">
                        <i data-lucide="hand"></i> Move
                    </button>
                    <button class="tool-btn danger" onclick="setMode('delete')" id="btn-delete">
                        <i data-lucide="trash-2"></i> Del
                    </button>
                </div>
                
                <button class="text-btn danger" onclick="resetGraph()" style="margin-top: 10px;">
                    <i data-lucide="rotate-ccw"></i> Clear Entire Map
                </button>
            </div>

            <div class="separator"></div>

            <div class="control-group">
                <h2>Simulation</h2>
                <select id="startNodeSelect">
                    <option value="">Select Start Node...</option>
                </select>
                
                <div class="btn-grid wide" style="margin-top: 10px;">
                    <button class="action-btn primary" onclick="runBFS()">
                        BFS
                    </button>
                    <button class="action-btn secondary" onclick="runDFS()">
                        DFS
                    </button>
                </div>
                
                <button class="text-btn" onclick="clearVisualization()" style="margin-top: 10px;">
                    <i data-lucide="eraser"></i> Reset Colors Only
                </button>
            </div>

            <div class="control-group" style="margin-top: auto;">
                <h2>System Log</h2>
                <div class="log-box" id="logBox">
                    <div class="log-entry">System Online</div>
                </div>
            </div>
        </div>
    </div>

    <!-- Zoom Controls -->
    <div class="zoom-controls">
        <button class="circle-btn" onclick="zoomCanvas(1)">
            <i data-lucide="plus"></i>
        </button>
        <button class="circle-btn" onclick="zoomCanvas(-1)">
            <i data-lucide="minus"></i>
        </button>
        <button class="circle-btn" onclick="resetView()" title="Fit to Screen">
            <i data-lucide="maximize"></i>
        </button>
    </div>

    <!-- Legend -->
    <div class="legend-pill">
        <div class="legend-item" style="color: var(--color-default)"><div class="dot" style="background: var(--color-default)"></div> Unvisited</div>
        <div class="legend-item" style="color: var(--color-visiting)"><div class="dot" style="background: var(--color-visiting)"></div> Active</div>
        <div class="legend-item" style="color: var(--color-visited)"><div class="dot" style="background: var(--color-visited)"></div> Visited</div>
    </div>

    <!-- Modal -->
    <div id="modalOverlay" class="modal-backdrop">
        <div class="modal-content">
            <h3>Add Location</h3>
            <input type="text" id="nodeNameInput" placeholder="Location Name (e.g. Library)" autocomplete="off">
            <div class="btn-grid wide">
                <button class="text-btn" onclick="closeModal()">Cancel</button>
                <button class="action-btn primary" onclick="confirmAddNode()">Confirm</button>
            </div>
        </div>
    </div>

    <!-- Toast -->
    <div id="toast">Alert</div>

<script>
    // Initialize Icons
    lucide.createIcons();

    // Elements
    const canvas = document.getElementById('graphCanvas');
    const ctx = canvas.getContext('2d');
    const wrapper = document.getElementById('canvas-wrapper');
    const instructions = document.getElementById('instructions');
    const logBox = document.getElementById('logBox');
    
    // State
    let nodes = [];
    let edges = [];
    let mode = 'node'; 
    let selectedNode = null;
    let nodeCounter = 1;
    let isAnimating = false;
    let view = { x: 0, y: 0, scale: 1 };
    
    // Mouse Tracking
    let isDragging = false;
    let lastMouse = { x: 0, y: 0 };
    let pendingNodeCoords = { x: 0, y: 0 };

    function init() {
        resize();
        window.addEventListener('resize', resize);
        wrapper.addEventListener('wheel', handleWheel, { passive: false });
        wrapper.addEventListener('mousedown', handleDown);
        wrapper.addEventListener('mousemove', handleMove);
        wrapper.addEventListener('mouseup', handleUp);
        document.getElementById('nodeNameInput').addEventListener('keypress', e => {
            if(e.key === 'Enter') confirmAddNode();
        });
        
        loadDemo();
        animateLoop(); // Start the animation loop for glow effects
    }

    function resize() {
        canvas.width = wrapper.clientWidth;
        canvas.height = wrapper.clientHeight;
        // No draw() here, handled by animateLoop
    }

    function loadDemo() {
        // Reset View
        view = { x: 0, y: 0, scale: 1 };
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        
        addNodeData(cx, cy - 150, "Library");
        addNodeData(cx - 150, cy, "Hostel");
        addNodeData(cx + 150, cy, "Cafeteria");
        addNodeData(cx, cy + 150, "Gym");
        addNodeData(cx, cy, "Admin");

        addEdgeData(0, 4); addEdgeData(1, 4); addEdgeData(2, 4);
        addEdgeData(3, 4); addEdgeData(0, 2);
        
        log("Demo map loaded.");
    }

    // --- Interaction ---

    function setMode(newMode) {
        if(isAnimating) return;
        mode = newMode;
        selectedNode = null;

        // UI Updates
        document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
        document.getElementById(`btn-${mode}`).classList.add('active');
        
        wrapper.className = ''; // Reset cursor
        
        if (mode === 'node') {
            instructions.textContent = "Click anywhere to add a Node";
            instructions.style.backgroundColor = "var(--primary)";
        } else if (mode === 'edge') {
            instructions.textContent = "Select two nodes to connect";
            instructions.style.backgroundColor = "var(--primary)";
        } else if (mode === 'pan') {
            instructions.textContent = "Drag to move • Scroll to zoom";
            wrapper.classList.add('pan-mode');
            instructions.style.backgroundColor = "var(--text-muted)";
        } else if (mode === 'delete') {
            instructions.textContent = "Click a node to delete it";
            wrapper.classList.add('delete-mode');
            instructions.style.backgroundColor = "var(--accent)";
        }
    }

    function getWorldCoords(e) {
        const rect = canvas.getBoundingClientRect();
        return {
            x: (e.clientX - rect.left - view.x) / view.scale,
            y: (e.clientY - rect.top - view.y) / view.scale
        };
    }

    function handleDown(e) {
        if(e.target.closest('.glass-panel') || e.target.closest('.zoom-controls')) return;
        
        const coords = getWorldCoords(e);
        const clickedIdx = getHoveredNode(coords.x, coords.y);
        
        if (mode === 'pan') {
            isDragging = true;
            lastMouse = { x: e.clientX, y: e.clientY };
            return;
        }

        if (mode === 'node') {
            if (clickedIdx === -1) {
                pendingNodeCoords = coords;
                openModal();
            }
        } else if (mode === 'edge') {
            if (clickedIdx !== -1) {
                if (selectedNode === null) {
                    selectedNode = clickedIdx;
                } else {
                    if (selectedNode !== clickedIdx) addEdgeData(selectedNode, clickedIdx);
                    selectedNode = null;
                }
            } else {
                selectedNode = null;
            }
        } else if (mode === 'delete') {
            if (clickedIdx !== -1) deleteNode(clickedIdx);
        }
    }

    function handleMove(e) {
        if (isDragging) {
            const dx = e.clientX - lastMouse.x;
            const dy = e.clientY - lastMouse.y;
            view.x += dx;
            view.y += dy;
            lastMouse = { x: e.clientX, y: e.clientY };
        }
    }

    function handleUp() { isDragging = false; }

    function handleWheel(e) {
        e.preventDefault();
        const zoomSpeed = 0.1;
        const dir = e.deltaY < 0 ? 1 : -1;
        zoomAt(e.clientX, e.clientY, dir * zoomSpeed);
    }

    function zoomCanvas(dir) {
        const cx = canvas.width / 2 + canvas.getBoundingClientRect().left;
        const cy = canvas.height / 2 + canvas.getBoundingClientRect().top;
        zoomAt(cx, cy, dir * 0.3);
    }

    function zoomAt(screenX, screenY, amount) {
        const rect = canvas.getBoundingClientRect();
        const worldX = (screenX - rect.left - view.x) / view.scale;
        const worldY = (screenY - rect.top - view.y) / view.scale;
        
        let newScale = view.scale + amount;
        if (newScale < 0.2) newScale = 0.2;
        if (newScale > 5) newScale = 5;
        
        view.x = (screenX - rect.left) - worldX * newScale;
        view.y = (screenY - rect.top) - worldY * newScale;
        view.scale = newScale;
    }
    
    function resetView() {
        view = { x: 0, y: 0, scale: 1 };
        // Center logic could be added here
        const cx = canvas.width / 2;
        const cy = canvas.height / 2;
        if(nodes.length > 0) {
            // Find centroid
            let avgX = 0, avgY = 0;
            nodes.forEach(n => { avgX += n.x; avgY += n.y; });
            avgX /= nodes.length;
            avgY /= nodes.length;
            view.x = cx - avgX;
            view.y = cy - avgY;
        }
    }

    // --- Data Ops ---

    function addNodeData(x, y, label) {
        nodes.push({ x, y, label, state: 'default' });
        log(`Created: ${label}`);
        updateSelect();
    }

    function addEdgeData(u, v) {
        if (edges.some(e => (e.u === u && e.v === v) || (e.u === v && e.v === u))) {
            showToast("Path already exists!");
            return;
        }
        edges.push({ u, v });
        log(`Linked: ${nodes[u].label} ↔ ${nodes[v].label}`);
    }

    function deleteNode(idx) {
        const name = nodes[idx].label;
        edges = edges.filter(e => e.u !== idx && e.v !== idx);
        edges.forEach(e => {
            if (e.u > idx) e.u--;
            if (e.v > idx) e.v--;
        });
        nodes.splice(idx, 1);
        log(`Deleted: ${name}`);
        updateSelect();
    }

    function getHoveredNode(x, y) {
        const r = 35;
        for(let i=0; i<nodes.length; i++) {
            const dx = x - nodes[i].x;
            const dy = y - nodes[i].y;
            if (dx*dx + dy*dy < r*r) return i;
        }
        return -1;
    }

    // --- Drawing System ---

    let time = 0;
    function animateLoop() {
        time += 0.05;
        draw();
        requestAnimationFrame(animateLoop);
    }

    function draw() {
        // Clear
        ctx.setTransform(1, 0, 0, 1, 0, 0);
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Grid
        drawGrid();

        // Apply Camera
        ctx.setTransform(view.scale, 0, 0, view.scale, view.x, view.y);

        // Draw Edges
        ctx.lineWidth = 2 / view.scale;
        if (ctx.lineWidth < 1) ctx.lineWidth = 1;

        edges.forEach(e => {
            const n1 = nodes[e.u];
            const n2 = nodes[e.v];
            
            ctx.beginPath();
            ctx.moveTo(n1.x, n1.y);
            ctx.lineTo(n2.x, n2.y);
            
            // Neon effect
            ctx.strokeStyle = 'rgba(148, 163, 184, 0.4)';
            ctx.shadowBlur = 0;
            ctx.stroke();
        });

        // Draw Nodes
        const r = 24; 
        nodes.forEach((n, i) => {
            ctx.beginPath();
            ctx.arc(n.x, n.y, r, 0, Math.PI * 2);
            
            // Base fill
            ctx.fillStyle = '#1e293b';
            
            // Selection / State Styles
            if (n.state === 'visited') {
                ctx.strokeStyle = '#34d399';
                ctx.shadowColor = '#34d399';
                ctx.shadowBlur = 15;
                ctx.fillStyle = '#064e3b';
            } else if (n.state === 'visiting') {
                ctx.strokeStyle = '#fbbf24';
                ctx.shadowColor = '#fbbf24';
                ctx.shadowBlur = 20 + Math.sin(time * 5) * 5; // Pulse
                ctx.fillStyle = '#78350f';
            } else {
                ctx.strokeStyle = (selectedNode === i) ? '#6366f1' : '#cbd5e1';
                ctx.shadowColor = (selectedNode === i) ? '#6366f1' : 'transparent';
                ctx.shadowBlur = (selectedNode === i) ? 20 : 0;
            }
            
            // Delete mode hover warning
            if (mode === 'delete' && !isAnimating) {
                // We need to check hover state efficiently or pass it in. 
                // For perf, simple red border if it was hovered would be handled by mousemove logic usually.
                // Here we keep it simple.
            }

            ctx.lineWidth = (selectedNode === i || n.state !== 'default') ? 3 : 2;
            // Scale linewidth inverse to zoom so it doesn't get huge
            ctx.lineWidth = ctx.lineWidth / view.scale < 1 ? 1 : ctx.lineWidth / view.scale;

            ctx.fill();
            ctx.stroke();
            
            // Reset shadow
            ctx.shadowBlur = 0;

            // Label
            ctx.fillStyle = '#f1f5f9';
            ctx.font = `600 ${12/view.scale + 4}px Inter`; // Dynamic font size
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(n.label.substring(0, 10), n.x, n.y);
        });
    }

    function drawGrid() {
        const step = 50 * view.scale;
        const offsetX = view.x % step;
        const offsetY = view.y % step;
        
        ctx.fillStyle = 'rgba(99, 102, 241, 0.15)';
        
        for (let x = offsetX; x < canvas.width; x += step) {
            for (let y = offsetY; y < canvas.height; y += step) {
                ctx.beginPath();
                ctx.arc(x, y, 1 * view.scale, 0, Math.PI*2);
                ctx.fill();
            }
        }
    }

    // --- UI Logic ---

    function toggleMenu() {
        const panel = document.getElementById('mainPanel');
        const icon = document.getElementById('toggleIcon');
        panel.classList.toggle('collapsed');
        
        if (panel.classList.contains('collapsed')) {
            icon.setAttribute('data-lucide', 'menu');
        } else {
            icon.setAttribute('data-lucide', 'chevrons-left');
        }
        lucide.createIcons();
    }

    function updateSelect() {
        const sel = document.getElementById('startNodeSelect');
        const curr = sel.value;
        sel.innerHTML = '<option value="">Select Start Node...</option>';
        nodes.forEach((n, i) => {
            const opt = document.createElement('option');
            opt.value = i;
            opt.text = n.label;
            sel.appendChild(opt);
        });
        if (curr && curr < nodes.length) sel.value = curr;
    }

    function log(msg) {
        const d = document.createElement('div');
        d.className = 'log-entry';
        d.textContent = msg;
        logBox.appendChild(d);
        logBox.scrollTop = logBox.scrollHeight;
    }

    function showToast(msg) {
        const t = document.getElementById('toast');
        t.textContent = msg;
        t.style.display = 'block';
        setTimeout(() => t.style.display = 'none', 3000);
    }

    // Modal
    const modal = document.getElementById('modalOverlay');
    const nameInput = document.getElementById('nodeNameInput');
    
    function openModal() {
        nameInput.value = `Node ${nodeCounter}`;
        modal.style.display = 'flex';
        // Slight delay for animation
        requestAnimationFrame(() => modal.classList.add('modal-active'));
        nameInput.focus();
        nameInput.select();
    }
    
    function closeModal() {
        modal.classList.remove('modal-active');
        setTimeout(() => modal.style.display = 'none', 300);
    }
    
    function confirmAddNode() {
        const name = nameInput.value.trim();
        if(name) {
            addNodeData(pendingNodeCoords.x, pendingNodeCoords.y, name);
            nodeCounter++;
            closeModal();
        }
    }

    // --- Algorithms ---

    async function runBFS() {
        if(isAnimating) return;
        const start = parseInt(document.getElementById('startNodeSelect').value);
        if(isNaN(start)) { showToast("Select a start node!"); return; }
        
        startAlgo("BFS");
        let q = [start];
        let visited = new Set([start]);
        nodes[start].state = 'visiting';
        
        while(q.length > 0) {
            const u = q.shift();
            // Pulse effect
            await sleep(500);
            nodes[u].state = 'visited';
            
            // Neighbors
            const neighbors = edges
                .filter(e => e.u === u || e.v === u)
                .map(e => e.u === u ? e.v : e.u);
                
            for(let v of neighbors) {
                if(!visited.has(v)) {
                    visited.add(v);
                    nodes[v].state = 'visiting';
                    q.push(v);
                    await sleep(300);
                }
            }
        }
        endAlgo();
    }

    async function runDFS() {
        if(isAnimating) return;
        const start = parseInt(document.getElementById('startNodeSelect').value);
        if(isNaN(start)) { showToast("Select a start node!"); return; }

        startAlgo("DFS");
        await dfsRec(start, new Set());
        endAlgo();
    }

    async function dfsRec(u, visited) {
        visited.add(u);
        nodes[u].state = 'visiting';
        await sleep(600);
        nodes[u].state = 'visited';
        
        const neighbors = edges
            .filter(e => e.u === u || e.v === u)
            .map(e => e.u === u ? e.v : e.u);
            
        for(let v of neighbors) {
            if(!visited.has(v)) {
                await dfsRec(v, visited);
            }
        }
    }

    function startAlgo(name) {
        isAnimating = true;
        resetStates();
        log(`Running ${name}...`);
        document.body.style.cursor = "wait";
    }

    function endAlgo() {
        isAnimating = false;
        document.body.style.cursor = "default";
        log("Done.");
    }

    function sleep(ms) { return new Promise(r => setTimeout(r, ms)); }
    
    function resetStates() {
        nodes.forEach(n => n.state = 'default');
    }
    
    function clearVisualization() {
        if(isAnimating) return;
        resetStates();
        log("Colors reset.");
    }

    function resetGraph() {
        if(isAnimating) return;
        nodes = [];
        edges = [];
        nodeCounter = 1;
        updateSelect();
        view = { x: 0, y: 0, scale: 1 };
        log("Map Cleared.");
    }

    // Start
    init();

</script>
</body>
</html>